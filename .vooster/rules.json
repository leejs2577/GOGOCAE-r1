{
  "rules": [
    {
      "type": "prd",
      "content": "# GOGOCAE_R1 – Product Requirements Document (UPDATED)\n\n## 1. 제품 개요\nGOGOCAE_R1은 설계자와 해석자가 CAE 해석 요청·진행·보고를 한 곳에서 관리할 수 있는 클라우드 SaaS 웹 서비스이다. MVP 단계에서는 로그인/회원가입, 해석 요청 등록, 담당자 지정, 업무 상태 관리(작업전/진행중/완료), 캘린더/칸반 대시보드, 간단한 통계, 파일 업·다운로드에 집중하며, 퍼블릭 URL의 랜딩페이지를 통해 서비스 소개 및 로그인 진입을 제공한다.\n\n## 2. 랜딩페이지 요구 사항\n| 섹션 | 설명 |\n|------|------|\n| 헤드라인 & 핵심 가치 | \"CAE 해석 업무를 한눈에.\" 등 한줄 메시지 + 콜투액션(회원가입/로그인) |\n| 주요 기능 카드 | 해석 요청, 담당자 지정, 캘린더·칸반, 파일 관리 4개 카드로 요약 |\n| 사용 흐름 다이어그램 | \"요청 → 진행 → 완료\" 3단계 일러스트 |\n| 스크린샷/GIF | 대시보드, 칸반, 캘린더 UI 미리보기 |\n\n## 3. 문제 정의(Pain Point)\n업무 상태 가시성이 부족해 우선순위를 파악하기 어렵고, 기존 flow.team은 CAE 전용 프로세스 맞춤화가 불가하다.\n\n## 4. 목표(Primary Goal)\n우선순위가 높은 작업을 해석자가 한눈에 식별하고 자원을 최적 배분하도록 지원한다.\n\n## 5. 주요 사용자(Persona)\n● 김해석 (해석 엔지니어) – 메인 사용자  \n● 박설계 (설계 엔지니어)\n\n## 6. Use Case (주요 시나리오)\n1) 방문자가 퍼블릭 랜딩페이지에서 서비스 개요를 확인하고 \"로그인/회원가입\" 클릭.  \n2) 이메일·비밀번호로 가입/로그인 후 대시보드 진입.  \n3) 설계자가 해석 요청을 생성 → 해석자가 담당 지정·진행 → 보고서 업로드 → 설계자가 다운로드.\n\n## 7. 핵심 기능 (MVP)\n1. 이메일 기반 회원가입/로그인  \n2. 해석 요청 양식 (요청명, 차종, 날짜, 파일 첨부)  \n3. 담당자 지정 & 업무 상태 변경(담당자 지정필요/작업전/진행중/완료)  \n4. 파일 관리 (모델 업로드, 보고서 업·다운로드)  \n5. 대시보드 – 통계 카드, 캘린더 뷰, 칸반 뷰  \n6. 권한: 설계자/해석자/관리자\n\n## 8. 향후 기능(Backlog)\n우선순위 태그, 검색·필터, 댓글/메모, 데이터 시각화, 이메일/Slack 알림\n\n## 9. 성공 지표(Metrics)\n• 평균 리드타임 30% 감소  \n• 미지정 상태 지속 시간 50% 감소  \n• 로그인 DAU 80% 이상  \n• 설계자 요청 작성 시간 50% 단축\n\n## 10. 기술 & 운영\n• 배포: 클라우드(SaaS)  \n• 개발: MVP→Agile 2주 스프린트  \n• 초기 동접: 6~15명, 확장 40명까지 고려\n\n## 11. 일정(High-level Roadmap)\n| 기간 | 마일스톤 |\n|------|-----------|\n| 0~2주 | 요구 확정, IA, UI 시안, 랜딩페이지 초안 |\n| 3~6주 | 인증, 요청 등록, 담당 지정, 칸반·캘린더 뷰 |\n| 7~8주 | 파일 관리, 대시보드 통계, 랜딩페이지 최종 배포 |\n| 9주 | UAT, 버그 수정 |\n| 10주 | MVP 출시 |\n\n## 12. 리스크 & 대응\n• 파일 용량 증가 → 클라우드 스토리지 + 아카이브  \n• 데이터 보안 → HTTPS, 역할 기반 권한  \n• 사용자 교육 → 짧은 온보딩 튜토리얼 제공\n\n---\n업데이트: 2025-10-04 (랜딩페이지 및 일반 이메일 로그인 반영)\n작성자: Vooster",
      "writedAt": "2025-10-04T03:09:12.192Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 명세서 (TRD)\n\n## 1. 기술 요약\n- **프로젝트 개요**: 본 문서는 GOGOCAE_R1 프로젝트의 기술적 요구사항을 정의합니다. GOGOCAE_R1은 설계자와 해석자가 CAE(Computer-Aided Engineering) 해석 업무를 통합 관리하는 클라우드 기반 SaaS 웹 서비스입니다. 본 프로젝트의 기술 아키텍처는 빠른 MVP(Minimum Viable Product) 개발과 안정적인 확장을 목표로, 검증된 기술 스택을 활용하여 비즈니스 요구사항을 가장 직접적이고 효율적으로 충족시키는 데 중점을 둡니다.\n- **핵심 기술 스택**: 프론트엔드와 백엔드 API는 Next.js(TypeScript)를 사용하여 통합 개발하고, 데이터베이스, 인증, 파일 스토리지는 Supabase BaaS(Backend as a Service)를 활용합니다. 전체 서비스는 Vercel 플랫폼을 통해 배포 및 운영됩니다. 이 조합은 개발 생산성을 극대화하고 초기 인프라 관리 비용을 최소화합니다.\n- **주요 기술 목표**:\n    - **성능**: 사용자가 캘린더/칸반 보드에서 업무 상태를 실시간에 가깝게 확인하고, 파일 업로드/다운로드를 원활하게 수행할 수 있는 응답 속도 확보.\n    - **확장성**: 초기 동시 접속자 15명에서 향후 40명 이상으로 증가 시, Vercel의 서버리스 아키텍처와 Supabase의 확장성을 통해 안정적인 서비스 제공.\n    - **신뢰성 및 유지보수성**: 역할 기반 접근 제어(RBAC)를 통한 데이터 보안을 보장하고, 도메인 주도 설계(DDD) 기반의 코드 구조를 통해 유지보수 용이성 확보.\n- **핵심 기술 가정**:\n    - Vercel과 Supabase의 프리 티어 또는 저비용 플랜으로 MVP 단계의 트래픽(동접 6~15명)을 충분히 감당할 수 있다고 가정합니다.\n    - 사용자가 업로드하는 파일의 평균 크기와 총량이 Supabase Storage의 정책 및 비용 모델에 부합한다고 가정합니다.\n    - 이메일 기반 인증만으로 MVP 단계의 사용자 인증 요구사항을 충족한다고 가정합니다.\n\n## 2. 기술 스택\n요구사항을 충족하는 가장 직접적이고 효율적인 기술 스택을 선정했습니다. 이는 과도한 엔지니어링을 피하고 MVP의 신속한 시장 출시를 지원하기 위함입니다.\n\n| 분류 | 기술 / 라이브러리 | 선정 사유 |\n| :--- | :--- | :--- |\n| **프론트엔드** | Next.js (with TypeScript) | React 기반의 높은 생산성과 다양한 렌더링(SSR, SSG) 옵션을 제공하여 빠른 초기 로딩 속도와 우수한 사용자 경험을 보장합니다. TypeScript를 통해 코드 안정성과 유지보수성을 강화합니다. |\n| **백엔드 API** | Node.js (Next.js API Routes) | 별도의 서버 구축 없이 Next.js 프레임워크 내에서 서버리스 함수 형태로 API를 간편하게 개발 및 배포할 수 있습니다. 이는 개발 복잡성을 줄이고 Vercel 배포에 최적화된 구조입니다. |\n| **데이터베이스** | PostgreSQL (on Supabase) | 높은 안정성과 확장성을 지닌 오픈소스 RDBMS로, 복잡한 데이터 관계를 효과적으로 모델링할 수 있습니다. Supabase를 통해 손쉬운 관리와 자동 생성 API의 이점을 얻습니다. |\n| **인증** | Supabase Auth | 이메일/비밀번호 기반 회원가입 및 로그인, 역할 기반 접근 제어(RBAC) 구현을 위한 포괄적인 기능을 제공하여 보안 인증 로직 개발 시간을 단축시킵니다. |\n| **파일 스토리지** | Supabase Storage | 대용량 모델 및 보고서 파일의 안전한 업로드, 다운로드, 접근 제어 기능을 제공합니다. Vercel 및 Supabase DB와 긴밀하게 통합되어 개발이 용이합니다. |\n| **배포/호스팅** | Vercel | Next.js 개발 및 배포에 최적화된 플랫폼으로, CI/CD 파이프라인 자동화, 글로벌 CDN, 서버리스 환경을 기본 제공하여 인프라 관리 부담 없이 빠른 배포와 안정적인 운영을 지원합니다. |\n\n## 3. 시스템 아키텍처 설계\n\n### 최상위 구성 요소\n- **Next.js 웹 애플리케이션 (프론트엔드 & 백엔드)**: Vercel에서 실행되며, 사용자에게 UI를 제공하고 비즈니스 로직을 처리합니다.\n    - **프론트엔드 (UI Layer)**: React 컴포넌트 기반의 사용자 인터페이스. 랜딩페이지, 대시보드, 칸반/캘린더 뷰 등을 포함합니다.\n    - **백엔드 (API Routes)**: Next.js API Routes를 활용한 서버리스 API. 데이터베이스 CRUD, 파일 관리, 인증 처리 등 서버 측 로직을 수행합니다.\n- **Supabase (BaaS 플랫폼)**: 백엔드 인프라의 핵심 기능을 제공하는 외부 서비스입니다.\n    - **PostgreSQL 데이터베이스**: 애플리케이션의 모든 데이터(사용자, 해석 요청, 파일 메타데이터 등)를 저장합니다.\n    - **Supabase Auth**: 사용자 인증 및 세션 관리를 전담합니다.\n    - **Supabase Storage**: 사용자가 업로드하는 CAE 모델 및 결과 보고서 파일을 저장합니다.\n- **Vercel (배포 및 호스팅 플랫폼)**: Next.js 애플리케이션의 빌드, 배포, 호스팅을 담당하는 클라우드 플랫폼입니다.\n\n### 최상위 컴포넌트 상호작용 다이어그램\n```mermaid\ngraph TD\n    subgraph 사용자\n        A[설계자/해석자]\n    end\n\n    subgraph Vercel 플랫폼\n        B[Next.js 프론트엔드]\n        C[Next.js API Routes]\n    end\n    \n    subgraph Supabase BaaS\n        D[Supabase Auth]\n        E[PostgreSQL DB]\n        F[Supabase Storage]\n    end\n\n    A -- HTTPS --> B\n    B -- API 호출 --> C\n    C -- SDK/API --> D\n    C -- SDK/API --> E\n    C -- SDK/API --> F\n```\n\n- **사용자 요청 처리**: 사용자는 브라우저를 통해 Vercel에 배포된 Next.js 프론트엔드와 상호작용합니다.\n- **API 통신**: 프론트엔드에서 발생하는 데이터 요청(예: 해석 요청 목록 조회)은 Next.js API Routes로 전달됩니다.\n- **백엔드 서비스 연동**: API Routes는 Supabase SDK를 사용하여 인증(Auth), 데이터베이스(PostgreSQL) 조회/수정, 파일 저장소(Storage) 접근 등 필요한 백엔드 작업을 처리합니다.\n- **데이터 응답**: 처리 결과는 API Routes를 통해 프론트엔드로 다시 전달되어 사용자 화면에 렌더링됩니다.\n\n### 코드 구성 및 규칙\n**도메인 주도 구성 전략**\n- **도메인 분리**: 코드를 비즈니스 도메인(예: `auth`, `requests`, `dashboard`) 단위로 구성하여 응집도를 높이고 결합도를 낮춥니다.\n- **계층 기반 아키텍처**: 각 도메인 내부는 `components`(UI), `hooks`(상태 및 로직), `services`(API 통신), `types`(데이터 모델) 등 기능적 계층으로 분리하여 관심사를 명확히 구분합니다.\n- **기능 기반 모듈**: 관련된 기능(예: 해석 요청 생성 폼, 요청 목록 테이블)을 하나의 모듈로 그룹화하여 재사용성과 유지보수성을 향상시킵니다.\n- **공유 컴포넌트**: 여러 도메인에서 공통으로 사용되는 UI 컴포넌트, 유틸리티 함수, 타입 정의 등은 `shared` 또는 `common` 디렉토리에서 중앙 관리합니다.\n\n**범용 파일 및 폴더 구조**\n```\n/\n├── public/                  # 정적 에셋 (이미지, 폰트)\n├── src/\n│   ├── app/                 # Next.js App Router (페이지 및 레이아웃)\n│   │   ├── (auth)/          # 인증 관련 페이지 (로그인, 회원가입)\n│   │   ├── (main)/          # 메인 애플리케이션 페이지 (대시보드 등)\n│   │   │   ├── dashboard/\n│   │   │   └── layout.tsx\n│   │   └── page.tsx         # 랜딩 페이지\n│   ├── components/          # 공통 UI 컴포넌트 (Button, Input 등)\n│   ├── domains/             # 비즈니스 도메인별 로직 및 컴포넌트\n│   │   ├── auth/            # 인증 도메인\n│   │   ├── request/         # 해석 요청 도메인\n│   │   │   ├── components/\n│   │   │   ├── services/\n│   │   │   └── types.ts\n│   │   └── dashboard/       # 대시보드 도메인\n│   ├── lib/                 # 외부 라이브러리 설정 (Supabase 클라이언트 등)\n│   ├── services/            # 전역 API 서비스 또는 유틸리티\n│   └── styles/              # 전역 스타일\n├── next.config.js\n└── tsconfig.json\n```\n\n### 데이터 흐름 및 통신 패턴\n- **클라이언트-서버 통신**: 클라이언트(브라우저)는 Next.js API Routes에 HTTP(S) 기반의 RESTful API 요청을 보냅니다. 데이터 교환 형식은 JSON을 사용합니다.\n- **데이터베이스 상호작용**: 백엔드(API Routes)는 `supabase-js` SDK를 사용하여 타입-세이프(type-safe)한 방식으로 Supabase의 PostgreSQL 데이터베이스와 상호작용합니다.\n- **외부 서비스 통합**: 모든 외부 서비스(Supabase Auth, Storage) 연동은 보안을 위해 서버 측(API Routes)에서 처리하는 것을 원칙으로 합니다.\n- **파일 업로드/다운로드**:\n    1.  클라이언트가 파일 업로드/다운로드를 요청합니다.\n    2.  백엔드는 Supabase SDK를 사용해 해당 파일에 접근할 수 있는 시간제한이 있는 서명된 URL(signed URL)을 생성하여 클라이언트에 전달합니다.\n    3.  클라이언트는 이 URL을 사용해 Supabase Storage에 직접 파일을 업로드하거나 다운로드합니다. 이 방식은 서버의 부하를 줄이고 보안을 강화합니다.\n\n## 4. 성능 및 최적화 전략\n- **프론트엔드 렌더링 최적화**: 정적인 랜딩페이지는 SSG(Static Site Generation)를, 동적인 대시보드 데이터는 SSR(Server-Side Rendering) 또는 CSR(Client-Side Rendering)을 조합하여 초기 로딩 속도와 데이터 최신성을 모두 확보합니다.\n- **데이터베이스 쿼리 효율화**: 복잡한 조회 로직에는 데이터베이스 인덱스(index)를 적용하고, 필요한 데이터만 `SELECT`하여 네트워크 트래픽을 최소화합니다.\n- **자산(Asset) 최적화**: Next.js의 `Image` 컴포넌트를 활용하여 이미지를 자동으로 최적화하고, 코드 분할(Code Splitting)을 통해 페이지별로 필요한 JavaScript만 로드하여 초기 로딩 성능을 향상시킵니다.\n- **CDN 활용**: Vercel의 글로벌 Edge Network(CDN)를 통해 전 세계 사용자에게 정적 자산을 빠르게 제공하여 지연 시간을 최소화합니다.\n\n## 5. 구현 로드맵 및 마일스톤\n### 1단계: 기반 구축 (MVP 구현)\n- **핵심 인프라**: Vercel 프로젝트 생성, Supabase 프로젝트 설정(DB 스키마, Auth, Storage 버킷).\n- **필수 기능**:\n    - 이메일 기반 회원가입/로그인 (Supabase Auth 연동)\n    - 역할(설계자/해석자) 기반 접근 제어(RBAC) 기본 골격 구현\n    - 해석 요청 생성/조회/수정 기능 (폼, API, DB 테이블)\n    - 담당자 지정 및 업무 상태 변경 기능\n    - 칸반 보드 및 캘린더 뷰 UI/UX 프로토타입 구현\n    - 파일 업로드 및 다운로드 기능 (Supabase Storage 연동)\n- **개발 환경 설정**: 개발 환경용 CI/CD 파이프라인 구축 (Vercel 연동).\n- **예상 기간**: 3주 ~ 8주 (PRD 일정 기준)\n\n### 2단계: 기능 고도화\n- **고급 기능**: PRD 백로그 기능 구현 (우선순위 태그, 검색/필터, 댓글 기능).\n- **성능 최적화**: MVP 운영 데이터 기반의 성능 병목 구간(느린 쿼리, 비효율적 렌더링) 분석 및 개선.\n- **보안 강화**: 상세한 권한 정책 적용 및 보안 취약점 점검.\n- **모니터링 구현**: Vercel Analytics, Supabase Logs 등을 활용한 사용자 행동 및 시스템 상태 모니터링 시스템 구축.\n- **알림 기능**: 이메일 또는 Slack을 통한 주요 이벤트(신규 요청, 상태 변경) 알림 기능 구현.\n- **예상 기간**: MVP 출시 후 2~4개월\n\n## 6. 리스크 분석 및 완화 전략\n### 기술 리스크 분석\n- **기술 종속성 리스크**: Vercel 및 Supabase 플랫폼에 대한 높은 의존성.\n    - **완화 전략**: 서비스 초기에는 플랫폼이 제공하는 생산성의 이점을 최대한 활용. 향후 서비스 규모가 커질 경우, 표준 기술(Next.js, PostgreSQL) 기반이므로 다른 클라우드(AWS, GCP)로의 마이그레이션 계획을 수립할 수 있음.\n- **성능 리스크**: 데이터 및 파일 용량 증가 시 데이터베이스 쿼리 속도 저하 또는 스토리지 비용 급증.\n    - **완화 전략**: 주기적인 데이터베이스 인덱싱 및 쿼리 최적화 수행. 파일에 대한 아카이빙 정책을 수립하고, Supabase의 비용 모델을 지속적으로 모니터링하여 예산을 관리.\n- **보안 리스크**: 파일 및 데이터에 대한 부적절한 접근 또는 유출.\n    - **완화 전략**: Supabase의 RLS(Row-Level Security) 정책과 역할 기반 접근 제어(RBAC)를 엄격하게 적용. 모든 통신은 HTTPS를 사용하고, 서명된 URL(signed URL)을 통해 파일 접근을 제어.\n\n### 프로젝트 납품 리스크\n- **일정 리스크**: MVP 개발 범위가 예상보다 커져 정해진 10주 내 출시가 지연될 가능성.\n    - **완화 전략**: 2주 단위의 애자일 스프린트를 통해 진행 상황을 투명하게 공유하고, 기능의 우선순위를 지속적으로 재조정. MVP의 핵심 가치에 집중하고 부가 기능은 과감히 2단계로 이관.\n- **리소스 리스크**: 특정 기술(예: Supabase RLS)에 대한 팀의 숙련도 부족으로 개발 지연.\n    - **완화 전략**: 개발 초기에 공식 문서 학습 및 PoC(Proof of Concept)를 통해 핵심 기술을 검증. 필요시 외부 전문가 자문 또는 페어 프로그래밍을 통해 지식 격차 해소.\n- **배포 리스크**: 프로덕션 환경에서 예상치 못한 설정 오류나 버그 발생.\n    - **완화 전략**: 개발(Development), 스테이징(Staging), 프로덕션(Production) 환경을 분리하여 운영. Vercel의 Preview Deployments 기능을 활용하여 배포 전 충분한 테스트(UAT)를 수행.",
      "writedAt": "2025-10-04T03:09:12.192Z"
    },
    {
      "type": "guideline",
      "content": "# GOGOCAE_R1 Code Guideline\n\nThis document provides the official coding standards and architectural patterns for the GOGOCAE_R1 project. Adherence to these guidelines is mandatory to ensure code quality, maintainability, and consistency.\n\n## 1. Project Overview\n\nGOGOCAE_R1 is a cloud-native SaaS web service for managing Computer-Aided Engineering (CAE) workflows.\n\n### Technical Context & Architecture\n- **Tech Stack**: The project is a full-stack TypeScript application built with Next.js. The backend is implemented as serverless API Routes within the same Next.js application.\n- **Backend as a Service (BaaS)**: Supabase provides the core backend infrastructure, including the PostgreSQL database, user authentication (Supabase Auth), and file management (Supabase Storage).\n- **Deployment**: The application is deployed and hosted on Vercel, which is optimized for the Next.js framework.\n- **Architectural Approach**: We employ a **Domain-Driven code organization**. Logic is separated by business domains (e.g., `auth`, `request`), and business-critical operations are handled exclusively on the server-side (API Routes) to ensure security and data integrity.\n\n## 2. Core Principles\n\n- **Domain-Driven Structure is Mandatory**: All code must be organized by business domain to ensure high cohesion and low coupling.\n- **Type Safety is Non-Negotiable**: Leverage TypeScript to its full potential; avoid `any` to prevent runtime errors and improve maintainability.\n- **Server-Side Logic First**: Complex business logic, data validation, and all Supabase interactions MUST reside in Next.js API Routes, not the client.\n- **Clarity Over Premature Optimization**: Write simple, readable code first. Optimize only when a measured performance bottleneck is identified.\n\n## 3. Language-Specific Guidelines (TypeScript/Next.js)\n\n### File Organization and Directory Structure\n\nThe project MUST follow the structure defined in the TRD. This organizes code by feature and domain, separating concerns effectively.\n\n```\n/src/\n├── app/                 # Next.js App Router: Pages, Layouts, API Routes\n│   ├── (auth)/          # Route group for authentication pages\n│   ├── (main)/          # Route group for authenticated app pages\n│   ├── api/             # All server-side API endpoints\n│   └── page.tsx         # Public landing page\n├── components/          # Global, reusable, stateless UI components (e.g., Button, Input)\n├── domains/             # CORE: Business domain logic and components\n│   ├── request/         # Example: \"CAE Request\" domain\n│   │   ├── components/  # Components specific to the 'request' domain\n│   │   ├── hooks/       # Custom hooks for 'request' domain logic\n│   │   ├── services/    # Client-side functions for calling 'request' APIs\n│   │   └── types.ts     # TypeScript types/interfaces for the 'request' domain\n│   └── ...              # Other domains (auth, dashboard)\n├── lib/                 # Third-party library initializations (e.g., Supabase client)\n└── styles/              # Global CSS files\n```\n\n### Import/Dependency Management\n\n- **MUST** use absolute paths for imports, configured in `tsconfig.json`. This improves refactoring and readability.\n- **MUST** order imports in the following sequence:\n    1.  React and Next.js imports\n    2.  External library imports\n    3.  Internal absolute path imports (`@/components`, `@/domains`)\n    4.  Relative path imports (`./`, `../`)\n\n```typescript\n// MUST: Follow this import order\nimport { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\n\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { useForm } from 'react-hook-form';\n\nimport { Button } from '@/components/ui/button';\nimport { useCreateRequest } from '@/domains/request/hooks/useCreateRequest';\nimport { RequestFormSchema, RequestFormData } from '@/domains/request/types';\n\nimport { FormInput } from './FormInput';\n```\n\n### Error Handling Patterns\n\n- **API Routes**: All API route handlers **MUST** be wrapped in a `try...catch` block to handle unexpected errors gracefully and return a standardized error response.\n\n```typescript\n// MUST: Standard API route error handling in /app/api/**/route.ts\nimport { NextResponse } from 'next/server';\n\nexport async function POST(request: Request) {  \n  try {\n    const body = await request.json();\n    // ... business logic\n    return NextResponse.json({ data: { id: 'new-id' } }, { status: 201 });\n  } catch (error) {\n    console.error('API Error:', error);\n    return NextResponse.json(\n      { error: { message: 'An internal server error occurred.' } },\n      { status: 500 }\n    );\n  }\n}\n```\n\n- **Client-Side Data Fetching**: Custom hooks for data fetching **MUST** return an `error` state. UI components must handle this state to provide user feedback.\n\n```typescript\n// MUST: Expose error state from custom hooks\nfunction useRequests() {\n  const [data, setData] = useState(null);\n  const [error, setError] = useState<Error | null>(null);\n  // ... fetching logic that sets data or error\n  return { data, error, isLoading };\n}\n```\n\n## 4. Code Style Rules\n\n### MUST Follow\n\n1.  **Naming Conventions**:\n    -   Components and Type/Interface names: `PascalCase` (e.g., `RequestForm`, `interface UserProfile`).\n    -   Variables, functions, and non-component files: `camelCase` (e.g., `currentUser`, `getRequestById.ts`).\n    -   Custom Hooks: Prefixed with `use` (`useUserData`).\n\n2.  **Function Components**:\n    -   **MUST** use arrow functions for declaring components. This ensures consistency.\n\n    ```typescript\n    // MUST: Use arrow functions for components\n    import React from 'react';\n\n    interface MyButtonProps {\n      label: string;\n    }\n\n    export const MyButton = ({ label }: MyButtonProps) => {\n      return <button>{label}</button>;\n    };\n    ```\n\n3.  **Explicit Typing**:\n    -   **MUST** provide explicit types for all function parameters and return values.\n    -   **MUST** use TypeScript `interface` for defining the shape of objects.\n\n4.  **Environment Variables**:\n    -   Client-side (browser-accessible) variables **MUST** be prefixed with `NEXT_PUBLIC_`.\n    -   Server-side-only variables **MUST NOT** have this prefix.\n\n### MUST NOT Do\n\n1.  **The `any` Type**:\n    -   **MUST NOT** use `any`. It defeats the purpose of TypeScript. Use `unknown` for safer type checking or define a specific type.\n\n    ```typescript\n    // MUST NOT: Use of 'any' is forbidden\n    function processData(data: any) { // Wrong\n      console.log(data.name); // Unsafe\n    }\n\n    // MUST: Define a type or use 'unknown'\n    interface Processable {\n      name: string;\n    }\n    function processData(data: Processable) { // Correct\n      console.log(data.name);\n    }\n    ```\n\n2.  **Default Exports**:\n    -   **MUST NOT** use `export default` for anything other than Next.js pages, layouts, and route handlers. Use named exports to avoid naming conflicts and improve discoverability.\n\n    ```typescript\n    // MUST NOT: Avoid default exports in components/utils\n    // utils.ts\n    export default function someUtil() { /* ... */ } // Wrong\n\n    // MUST: Use named exports\n    // utils.ts\n    export const someUtil = () => { /* ... */ }; // Correct\n    ```\n\n3.  **Large, Monolithic Components**:\n    -   A single component file **MUST NOT** exceed 200 lines of code.\n    -   Break down complex components into smaller, single-responsibility components.\n\n4.  **Magic Strings and Numbers**:\n    -   **MUST NOT** use hardcoded strings or numbers for values that are used in multiple places (e.g., status types, roles, API keys). Define them as constants in a central file.\n\n    ```typescript\n    // MUST NOT: Using magic strings\n    if (request.status === 'In Progress') { /* ... */ }\n\n    // MUST: Use constants\n    import { REQUEST_STATUS } from '@/domains/request/constants';\n    if (request.status === REQUEST_STATUS.IN_PROGRESS) { /* ... */ }\n    ```\n\n## 5. Architecture Patterns\n\n### Component/Module Structure\n\n-   **Global Components (`/src/components`)**: These are pure, stateless UI components used across multiple domains (e.g., `Button`, `Card`, `Input`). They should not contain any business logic.\n-   **Domain Components (`/src/domains/[domain]/components`)**: These components belong to a specific business domain. They compose global components and implement UI logic relevant to their domain (e.g., `RequestForm`, `DashboardCalendar`).\n-   **Custom Hooks (`/src/domains/[domain]/hooks`)**: Contain state management, data fetching, and side effects related to a domain. They are the primary way components interact with services.\n\n### Data Flow Pattern\n\nThe data flow is unidirectional and server-centric to maintain security and integrity.\n\n1.  **UI Component**: A user interaction triggers a function call from a custom hook.\n2.  **Custom Hook**: The hook executes a `service` function.\n3.  **Service Function**: A client-side service calls our internal Next.js API Route using `fetch`.\n4.  **API Route**: This is the **only** layer that interacts with the Supabase client (`supabase-js` SDK). It contains all business logic, validation, and data transformation.\n5.  **Supabase**: Executes the database query, authentication, or file operation.\n\n```typescript\n// Example: Creating a new CAE request\n\n// 1. /src/domains/request/components/CreateRequestButton.tsx\nimport { useCreateRequest } from '@/domains/request/hooks/useCreateRequest';\nexport const CreateRequestButton = () => {\n  const { create, isLoading } = useCreateRequest();\n  return <button onClick={() => create({ title: 'New Analysis' })} disabled={isLoading}>Create</button>;\n};\n\n// 2. & 3. /src/domains/request/hooks/useCreateRequest.ts (includes service call)\nimport { createRequest as createRequestService } from '@/domains/request/services/requestService';\nexport const useCreateRequest = () => {\n  // ... state logic\n  const create = async (data) => {\n    const result = await createRequestService(data);\n    // ... handle result\n  };\n  return { create, isLoading };\n};\n\n// /src/domains/request/services/requestService.ts\nexport const createRequest = async (data) => {\n  const response = await fetch('/api/requests', {\n    method: 'POST',\n    body: JSON.stringify(data),\n  });\n  return response.json();\n};\n\n// 4. /src/app/api/requests/route.ts (Server-side logic)\nimport { createServerClient } from '@/lib/supabase/server';\nexport async function POST(req: Request) {\n  const supabase = createServerClient();\n  const { data: { user } } = await supabase.auth.getUser();\n  if (!user) return new Response('Unauthorized', { status: 401 });\n\n  const body = await req.json();\n  // ... validation logic ...\n  const { data, error } = await supabase.from('requests').insert({ ...body, user_id: user.id });\n  // ... return NextResponse ...\n}\n```\n\n### State Management\n\n-   **Local State**: **MUST** use `useState` for state that is confined to a single component.\n-   **Shared State**: For state shared between a few nested components, **MUST** use `useContext` paired with `useReducer`. This avoids prop drilling without adding external dependencies.\n-   **Global State**: **MUST NOT** introduce a global state management library (e.g., Redux, Zustand, Jotai) for the MVP. The combination of custom hooks and context is sufficient.\n\n### API Design Standards\n\n-   **Endpoint Naming**: Use RESTful, resource-based naming conventions for API Routes (e.g., `/api/requests`, `/api/requests/[id]`).\n-   **HTTP Methods**: Use appropriate HTTP verbs:\n    -   `GET`: Retrieve resources.\n    -   `POST`: Create new resources.\n    -   `PUT`/`PATCH`: Update existing resources.\n    -   `DELETE`: Remove resources.\n-   **Response Structure**: API responses **MUST** follow a consistent JSON structure.\n\n```json\n// MUST: Standard success response\n{\n  \"data\": {\n    \"id\": \"123\",\n    \"title\": \"My CAE Request\"\n  }\n}\n\n// MUST: Standard error response\n{\n  \"error\": {\n    \"message\": \"You do not have permission to access this resource.\"\n  }\n}\n```",
      "writedAt": "2025-10-04T03:09:12.192Z"
    },
    {
      "type": "design-guide",
      "content": "# GOGOCAE_R1 Design Guide\n\n## 1. 전체적인 무드 (Overall Mood)\n\nGOGOCAE_R1은 CAE 해석 업무의 전문성과 신뢰성을 강조하는 **신뢰할 수 있고 전문적인(Trustworthy and Professional)** 무드를 추구합니다. B2B SaaS 환경에서 엔지니어들이 정확하고 효율적으로 업무를 처리할 수 있도록 차분하고 정돈된 시각적 경험을 제공합니다.\n\n핵심 디자인 철학:\n- **명확성**: 복잡한 해석 업무 플로우를 직관적으로 이해할 수 있는 인터페이스\n- **신뢰성**: 전문적이고 안정감 있는 컬러와 타이포그래피로 업무 도구로서의 신뢰감 구축\n- **효율성**: 최소한의 클릭으로 핵심 작업을 완료할 수 있는 사용자 중심 설계\n\n## 2. 참조 서비스 (Reference Service)\n\n- **이름**: Vooster.ai\n- **설명**: AI 기반 비즈니스 자동화 플랫폼\n- **디자인 무드**: 깔끔한 화이트 스페이스 활용과 선명한 블루 포인트 컬러로 전문성과 신뢰감을 동시에 표현\n- **Primary Color**: #3366FF\n- **Secondary Color**: #F5F7FA\n\n## 3. 색상 & 그라데이션 (Color & Gradient)\n\n### 컬러 팔레트\n- **Primary Color**: #1846FF (Royal Blue)\n- **Secondary Color**: #0B1F4B (Deep Navy)\n- **Accent Color**: #20C997 (Teal)\n- **Background**: #F5F7FA (Light Gray)\n- **Text Primary**: #1F2937 (Dark Gray)\n- **Text Secondary**: #6B7280 (Medium Gray)\n\n### 무드\n- **톤**: Cool, Low-Medium Saturation\n- **특성**: 차분하고 전문적인 느낌으로 장시간 작업에 적합한 눈의 피로도 최소화\n\n### 컬러 사용법\n중요도별 UI 요소 컬러 적용:\n1. **최고 우선순위**: Primary Blue (#1846FF) - 주요 CTA 버튼, 활성 상태\n2. **높은 우선순위**: Accent Teal (#20C997) - 성공 상태, 완료 배지\n3. **중간 우선순위**: Secondary Navy (#0B1F4B) - 헤더, 사이드바 배경\n4. **낮은 우선순위**: Background Gray (#F5F7FA) - 카드 배경, 구분선\n\n## 4. 타이포그래피 & 폰트 (Typography & Font)\n\n### 폰트 시스템\n- **기본 폰트**: Inter (Google Fonts)\n- **대체 폰트**: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif\n\n### 타이포그래피 계층\n- **Heading 1**: Inter SemiBold, 32px, Line Height 1.2\n- **Heading 2**: Inter SemiBold, 24px, Line Height 1.3\n- **Heading 3**: Inter SemiBold, 20px, Line Height 1.4\n- **Body Large**: Inter Regular, 16px, Line Height 1.5\n- **Body**: Inter Regular, 14px, Line Height 1.5\n- **Caption**: Inter Regular, 12px, Line Height 1.4, Color #6B7280\n\n### 글자 간격\n- **Letter Spacing**: -0.01em (Heading), 0em (Body)\n- **Paragraph Spacing**: 16px (Body), 12px (Caption)\n\n## 5. 레이아웃 & 구조 (Layout & Structure)\n\n### 그리드 시스템\n- **컨테이너 최대 너비**: 1440px\n- **사이드바 너비**: 240px (고정)\n- **메인 콘텐츠 영역**: 1200px (최대)\n- **그리드**: 12컬럼 시스템\n- **거터**: 24px\n- **마진**: 좌우 24px (모바일), 40px (데스크탑)\n\n### 레이아웃 원칙\n- **사이드바 네비게이션**: 좌측 고정형으로 모든 주요 기능에 빠른 접근 제공\n- **카드 기반 레이아웃**: 정보를 논리적 단위로 그룹화하여 가독성 향상\n- **화이트 스페이스**: 충분한 여백으로 정보 계층 구조 명확화\n\n### 반응형 브레이크포인트\n- **Desktop**: 1280px+\n- **Tablet**: 768px - 1279px\n- **Mobile**: 320px - 767px\n\n## 6. 비주얼 스타일 (Visual Style)\n\n### 아이콘 스타일\n- **타입**: Outline 스타일, 1.5px 스트로크\n- **배경**: 원형 배경 없음\n- **라이브러리**: Phosphor Icons 또는 Lucide\n- **크기**: 16px (Small), 20px (Medium), 24px (Large)\n\n### 이미지 & 일러스트레이션\n- **스타일**: 미니멀하고 기하학적인 형태\n- **컬러**: 브랜드 컬러 팔레트 내에서 사용\n- **용도**: 온보딩, 빈 상태(Empty State), 에러 페이지\n\n### 그림자 & 효과\n- **카드 그림자**: 0 1px 3px rgba(0,0,0,0.08)\n- **호버 효과**: 0 4px 12px rgba(0,0,0,0.12)\n- **포커스 링**: #20C997 2px 아웃라인\n\n## 7. UX 가이드 (UX Guide)\n\n### 타겟 사용자 대응 전략: Both (전문가 + 초보자)\n\n#### 전문가 사용자를 위한 UX\n- **효율성 중심**: 핵심 기능을 단축키와 우클릭 메뉴로 빠르게 접근\n- **정보 밀도**: 대시보드에서 'My Tasks' 중심의 집중적 정보 제공\n- **배치 작업**: 다중 선택으로 상태 일괄 변경 기능\n- **키보드 네비게이션**: 전체 인터페이스에서 키보드만으로 조작 가능\n\n#### 초보자 사용자를 위한 UX\n- **온보딩**: 첫 로그인 시 3-4단계 인터랙티브 투어 제공\n- **가이드**: '새 요청 만들기' 플로팅 버튼과 양식 내 힌트 텍스트\n- **도움말**: 도움말 센터 링크 및 튜토리얼 비디오 팝업\n- **피드백**: 명확한 성공/오류 메시지와 다음 단계 안내\n\n#### 공통 UX 원칙\n- **일관성**: 모든 페이지에서 동일한 인터랙션 패턴 유지\n- **예측 가능성**: 사용자 행동에 대한 즉각적이고 명확한 피드백\n- **접근성**: WCAG AA 기준 준수로 모든 사용자가 이용 가능\n\n## 8. UI 컴포넌트 가이드 (UI Component Guide)\n\n### 버튼 (Buttons)\n#### Primary Button\n- **배경**: #1846FF\n- **텍스트**: White\n- **Border Radius**: 6px\n- **Padding**: 12px 24px\n- **Font**: Inter Medium, 14px\n- **Hover**: 투명도 90%\n\n#### Secondary Button\n- **배경**: White\n- **텍스트**: #1846FF\n- **테두리**: 1px solid #1846FF\n- **Border Radius**: 6px\n- **Padding**: 12px 24px\n- **Hover**: 배경 #F8FAFC\n\n#### Ghost Button\n- **배경**: Transparent\n- **텍스트**: #6B7280\n- **Hover**: 배경 #F1F5F9\n\n### 입력 필드 (Input Fields)\n- **배경**: White\n- **테두리**: 1px solid #D1D5DB\n- **Border Radius**: 6px\n- **Padding**: 12px 16px\n- **Font**: Inter Regular, 14px\n- **Focus**: 테두리 #1846FF, 그림자 0 0 0 3px rgba(24,70,255,0.1)\n- **Error**: 테두리 #EF4444\n\n### 카드 (Cards)\n- **배경**: White\n- **Border Radius**: 8px\n- **그림자**: 0 1px 3px rgba(0,0,0,0.08)\n- **Padding**: 24px\n- **Hover**: 그림자 0 4px 12px rgba(0,0,0,0.12)\n\n### 네비게이션 바 (Navigation Bar)\n#### 사이드바\n- **너비**: 240px\n- **배경**: #0B1F4B\n- **텍스트**: White\n- **활성 항목**: 배경 rgba(255,255,255,0.1)\n- **아이콘**: 20px, White\n- **패딩**: 16px\n\n#### 상단 헤더\n- **높이**: 64px\n- **배경**: White\n- **그림자**: 0 1px 3px rgba(0,0,0,0.08)\n- **로고**: 좌측 정렬\n- **사용자 메뉴**: 우측 정렬\n\n### 상태 배지 (Status Badges)\n#### 미지정 (Unassigned)\n- **배경**: #FEF3C7\n- **텍스트**: #92400E\n- **Border Radius**: 16px\n\n#### 진행중 (In Progress)\n- **배경**: #DBEAFE\n- **텍스트**: #1E40AF\n- **Border Radius**: 16px\n\n#### 완료 (Completed)\n- **배경**: #D1FAE5\n- **텍스트**: #065F46\n- **Border Radius**: 16px\n\n### 모달 & 팝업 (Modals & Popups)\n- **오버레이**: rgba(0,0,0,0.5)\n- **배경**: White\n- **Border Radius**: 12px\n- **최대 너비**: 600px\n- **그림자**: 0 20px 25px rgba(0,0,0,0.1)\n- **애니메이션**: Fade + Scale 200ms ease-out\n\n### 테이블 (Tables)\n- **헤더 배경**: #F9FAFB\n- **테두리**: 1px solid #E5E7EB\n- **행 호버**: #F9FAFB\n- **셀 패딩**: 12px 16px\n- **폰트**: Inter Regular, 14px\n\n### 로딩 & 피드백 (Loading & Feedback)\n#### 로딩 스피너\n- **색상**: #1846FF\n- **크기**: 24px (기본), 16px (작은 버튼 내)\n- **애니메이션**: 회전 1초 linear infinite\n\n#### 토스트 메시지\n- **성공**: 배경 #10B981, 아이콘 체크마크\n- **오류**: 배경 #EF4444, 아이콘 X\n- **경고**: 배경 #F59E0B, 아이콘 느낌표\n- **위치**: 우상단 고정\n- **지속 시간**: 4초 자동 사라짐\n\n### 접근성 (Accessibility)\n- **컬러 대비**: WCAG AA 기준 4.5:1 이상\n- **포커스 표시**: #20C997 2px 아웃라인\n- **키보드 네비게이션**: Tab 순서 논리적 구성\n- **스크린 리더**: 모든 인터랙티브 요소에 적절한 라벨 제공\n\n### 모션 & 애니메이션 (Motion & Animation)\n- **상태 변경**: Fade + Slide 150ms ease-out\n- **호버 효과**: 100ms ease-out으로 투명도 변화\n- **페이지 전환**: 200ms ease-out으로 슬라이드 효과\n- **로딩 애니메이션**: 부드러운 회전과 진행률 표시",
      "writedAt": "2025-10-04T03:09:12.192Z"
    },
    {
      "type": "ia",
      "content": "# GOGOCAE_R1 정보구조(IA) 문서\n\n## 1. 사이트맵 (사이트맵)\n\n```\nGOGOCAE_R1 서비스 구조\n│\n├── 퍼블릭 영역 (Public Area)\n│   ├── 랜딩페이지 (/)\n│   │   ├── 헤드라인 & 핵심 가치 섹션\n│   │   ├── 주요 기능 카드 (4개)\n│   │   ├── 사용 흐름 다이어그램\n│   │   ├── 스크린샷/GIF 갤러리\n│   │   └── 회원가입/로그인 CTA\n│   │\n│   └── 인증 영역 (/auth)\n│       ├── 로그인 (/auth/login)\n│       ├── 회원가입 (/auth/signup)\n│       └── 비밀번호 재설정 (/auth/reset-password)\n│\n└── 인증된 사용자 영역 (Authenticated Area)\n    ├── 대시보드 (/dashboard)\n    │   ├── 통계 카드 섹션\n    │   ├── 최근 활동 피드\n    │   └── 빠른 작업 버튼\n    │\n    ├── 해석 요청 관리 (/requests)\n    │   ├── 요청 목록 (/requests)\n    │   ├── 새 요청 작성 (/requests/new)\n    │   └── 요청 상세 (/requests/:id)\n    │       ├── 기본 정보 탭\n    │       ├── 파일 관리 탭\n    │       └── 히스토리 탭\n    │\n    ├── 캘린더 뷰 (/calendar)\n    │   ├── 월간 뷰\n    │   └── 주간 뷰\n    │\n    ├── 칸반 보드 (/kanban)\n    │   ├── 담당자 지정 필요 컬럼\n    │   ├── 작업 전 컬럼\n    │   ├── 진행 중 컬럼\n    │   └── 완료 컬럼\n    │\n    ├── 파일 관리 (/files)\n    │   ├── 모든 파일 목록\n    │   ├── 업로드 히스토리\n    │   └── 다운로드 로그\n    │\n    ├── 통계 (/statistics)\n    │   ├── 전체 현황 대시보드\n    │   ├── 차종별 분석\n    │   └── 성과 지표 (KPI)\n    │\n    ├── 설정 (/settings)\n    │   ├── 프로필 관리 (/settings/profile)\n    │   ├── 계정 설정 (/settings/account)\n    │   └── 알림 설정 (/settings/notifications)\n    │\n    └── 도움말 (/help)\n        ├── 온보딩 튜토리얼\n        ├── FAQ\n        └── 사용 가이드 비디오\n```\n\n## 2. 사용자 흐름 (사용자 흐름)\n\n### 주요 작업 1: 서비스 발견 및 가입\n1. 사용자가 퍼블릭 랜딩페이지(/) 방문\n2. 헤드라인 \"CAE 해석 업무를 한눈에\" 확인\n3. 주요 기능 카드 4개 (해석 요청, 담당자 지정, 캘린더·칸반, 파일 관리) 검토\n4. 사용 흐름 다이어그램으로 프로세스 이해\n5. \"무료로 시작하기\" 버튼 클릭\n6. 회원가입 페이지(/auth/signup)로 이동\n7. 이메일, 비밀번호 입력 후 가입 완료\n8. 대시보드(/dashboard)로 자동 리다이렉트\n\n### 주요 작업 2: 해석 요청 생성 및 관리 (설계자 관점)\n1. 대시보드에서 \"새 요청 만들기\" 버튼 클릭\n2. 새 요청 작성 페이지(/requests/new)로 이동\n3. 요청 양식 작성 (요청명, 차종, 마감일, 우선순위)\n4. 모델 파일 업로드 (드래그 앤 드롭)\n5. \"요청 제출\" 버튼 클릭\n6. 요청 목록(/requests)으로 이동하여 생성된 요청 확인\n7. 상태가 \"담당자 지정 필요\"로 표시됨을 확인\n\n### 주요 작업 3: 해석 작업 수행 (해석자 관점)\n1. 대시보드에서 \"미지정\" 카드의 숫자 확인\n2. 칸반 보드(/kanban) 또는 요청 목록(/requests)으로 이동\n3. \"담당자 지정 필요\" 컬럼에서 새 요청 카드 확인\n4. 카드 클릭하여 요청 상세(/requests/:id)로 이동\n5. 기본 정보 탭에서 요청 내용 검토\n6. 파일 관리 탭에서 모델 파일 다운로드\n7. \"담당자로 지정\" 버튼 클릭\n8. 상태를 \"진행 중\"으로 변경\n9. 해석 작업 완료 후 보고서 파일 업로드\n10. 상태를 \"완료\"로 변경\n\n### 주요 작업 4: 진행 현황 모니터링\n1. 대시보드(/dashboard)에서 전체 현황 카드 확인\n2. 캘린더 뷰(/calendar)에서 마감일 기준 일정 확인\n3. 칸반 보드(/kanban)에서 각 단계별 작업 현황 파악\n4. 통계 페이지(/statistics)에서 성과 지표 및 트렌드 분석\n\n## 3. 네비게이션 구조 (네비게이션 구조)\n\n### 글로벌 네비게이션 바 (GNB)\n**상단 헤더 (고정형)**\n- 좌측: GOGOCAE_R1 로고\n- 우측: 사용자 프로필 드롭다운\n  - 내 프로필\n  - 설정\n  - 도움말\n  - 로그아웃\n\n### 사이드바 네비게이션 (240px 고정폭)\n**주 메뉴**\n1. 📊 대시보드 (/dashboard)\n2. 📋 해석 요청 (/requests)\n   - 새 요청 (+)\n3. 📅 캘린더 (/calendar)\n4. 📌 칸반 보드 (/kanban)\n5. 📁 파일 관리 (/files)\n6. 📈 통계 (/statistics)\n\n**하단 메뉴**\n7. ⚙️ 설정 (/settings)\n8. ❓ 도움말 (/help)\n\n### 브레드크럼 네비게이션\n메인 콘텐츠 상단에 현재 위치 표시\n예: 대시보드 > 해석 요청 > 요청 상세 > 파일 관리\n\n### 탭 네비게이션 (요청 상세 페이지)\n- 기본 정보\n- 파일 관리\n- 히스토리\n\n## 4. 페이지 계층 구조 (페이지 계층 구조)\n\n```\n/ (Depth 1) - 랜딩페이지\n├── /auth (Depth 2) - 인증 영역\n│   ├── /auth/login (Depth 3)\n│   ├── /auth/signup (Depth 3)\n│   └── /auth/reset-password (Depth 3)\n│\n└── /app (Depth 2) - 인증된 사용자 영역\n    ├── /dashboard (Depth 3)\n    ├── /requests (Depth 3)\n    │   ├── /requests/new (Depth 4)\n    │   └── /requests/:id (Depth 4)\n    │       ├── /requests/:id/info (Depth 5)\n    │       ├── /requests/:id/files (Depth 5)\n    │       └── /requests/:id/history (Depth 5)\n    ├── /calendar (Depth 3)\n    ├── /kanban (Depth 3)\n    ├── /files (Depth 3)\n    ├── /statistics (Depth 3)\n    ├── /settings (Depth 3)\n    │   ├── /settings/profile (Depth 4)\n    │   ├── /settings/account (Depth 4)\n    │   └── /settings/notifications (Depth 4)\n    └── /help (Depth 3)\n```\n\n## 5. 콘텐츠 구성 (콘텐츠 구성)\n\n| 페이지 | 주요 콘텐츠 요소 | 인터랙션 요소 |\n|--------|------------------|---------------|\n| 랜딩페이지 | 헤드라인, 기능 소개 카드 4개, 워크플로우 다이어그램, UI 스크린샷 | CTA 버튼 (회원가입/로그인) |\n| 대시보드 | 통계 카드 (미지정/진행중/완료), 최근 활동 피드, 빠른 작업 버튼 | 새 요청 생성 FAB, 카드 클릭 |\n| 해석 요청 목록 | 요청 테이블 (제목, 차종, 상태, 담당자, 마감일), 필터 및 검색 | 정렬, 필터링, 페이지네이션 |\n| 요청 상세 - 기본 정보 | 요청 제목, 차종, 생성일, 마감일, 상태 배지, 담당자 정보 | 담당자 지정, 상태 변경 드롭다운 |\n| 요청 상세 - 파일 관리 | 업로드된 모델 파일 목록, 보고서 파일 목록 | 파일 업로드 (드래그앤드롭), 다운로드 |\n| 요청 상세 - 히스토리 | 상태 변경 로그, 파일 업로드 로그, 댓글 (향후) | 타임라인 뷰 |\n| 캘린더 | 월간/주간 뷰 전환, 마감일 표시된 요청 카드 | 뷰 전환 토글, 날짜 네비게이션 |\n| 칸반 보드 | 4개 컬럼 (담당자지정필요/작업전/진행중/완료), 요청 카드 | 드래그 앤 드롭으로 상태 변경 |\n| 파일 관리 | 전체 파일 목록, 파일 타입 필터, 연결된 요청 링크 | 파일 검색, 타입별 필터링 |\n| 통계 | KPI 카드, 차종별 파이 차트, 월별 완료 트렌드 | 기간 선택 필터 |\n| 설정 - 프로필 | 사용자 아바타, 이름, 이메일, 역할, 소속 | 프로필 편집 폼 |\n\n## 6. 인터랙션 패턴 (인터랙션 패턴)\n\n### 데이터 입력 패턴\n- **양식 작성**: 단계별 진행 표시와 실시간 유효성 검증\n- **파일 업로드**: 드래그 앤 드롭 + 클릭 업로드 병행 지원\n- **드롭다운 선택**: 검색 가능한 드롭다운으로 담당자 선택\n\n### 상태 변경 패턴\n- **상태 배지 클릭**: 드롭다운 메뉴로 즉시 상태 변경 가능\n- **칸반 드래그**: 카드를 다른 컬럼으로 드래그하여 상태 변경\n- **일괄 작업**: 체크박스 다중 선택으로 여러 요청 동시 처리\n\n### 피드백 패턴\n- **성공 알림**: 우상단 토스트 메시지 (4초 자동 사라짐)\n- **오류 처리**: 인라인 오류 메시지 + 필드 하이라이트\n- **로딩 상태**: 스피너 + 진행률 표시 (파일 업로드 시)\n\n### 네비게이션 패턴\n- **브레드크럼**: 현재 위치 및 상위 페이지로 빠른 이동\n- **뒤로 가기**: 브라우저 히스토리 지원 + 명시적 뒤로 가기 버튼\n- **딥링크**: 특정 요청이나 상태로 직접 접근 가능한 URL\n\n### 검색 및 필터 패턴\n- **실시간 검색**: 입력 시 즉시 결과 필터링\n- **다중 필터**: 상태, 담당자, 차종을 조합한 복합 필터링\n- **저장된 필터**: 자주 사용하는 필터 조합 저장 (향후)\n\n## 7. URL 구조 (URL 구조)\n\n### URL 네이밍 규칙\n- **일반 원칙**: 소문자, 하이픈(-) 사용, 복수형 리소스명\n- **계층 구조**: 상위 리소스 → 하위 리소스 순서\n- **의미 있는 경로**: 사용자가 URL만 보고도 페이지 내용 추측 가능\n\n### 구체적인 URL 구조\n\n#### 퍼블릭 영역\n- **랜딩페이지**: `/`\n- **로그인**: `/auth/login`\n- **회원가입**: `/auth/signup`\n- **비밀번호 재설정**: `/auth/reset-password`\n\n#### 인증된 사용자 영역\n- **대시보드**: `/dashboard`\n- **해석 요청 목록**: `/requests`\n- **새 요청 작성**: `/requests/new`\n- **요청 상세**: `/requests/:id`\n  - 기본 정보: `/requests/:id` (기본 탭)\n  - 파일 관리: `/requests/:id/files`\n  - 히스토리: `/requests/:id/history`\n- **캘린더**: `/calendar`\n  - 월간 뷰: `/calendar?view=month`\n  - 주간 뷰: `/calendar?view=week`\n- **칸반 보드**: `/kanban`\n- **파일 관리**: `/files`\n- **통계**: `/statistics`\n- **설정**: `/settings`\n  - 프로필: `/settings/profile`\n  - 계정: `/settings/account`\n  - 알림: `/settings/notifications`\n- **도움말**: `/help`\n\n#### 쿼리 파라미터 활용\n- **필터링**: `/requests?status=in-progress&assignee=김해석`\n- **정렬**: `/requests?sort=deadline&order=asc`\n- **페이지네이션**: `/requests?page=2&limit=20`\n- **검색**: `/requests?search=엔진%20해석`\n\n## 8. 컴포넌트 계층 구조 (컴포넌트 계층 구조)\n\n### 글로벌 컴포넌트 (모든 페이지 공통)\n- **AppLayout**: 전체 레이아웃 컨테이너\n  - **Header**: 상단 네비게이션 바\n    - **Logo**: 브랜드 로고\n    - **UserMenu**: 사용자 프로필 드롭다운\n  - **Sidebar**: 좌측 사이드바 네비게이션\n    - **NavItem**: 개별 네비게이션 항목\n  - **MainContent**: 메인 콘텐츠 영역\n  - **Toast**: 알림 메시지 컨테이너\n\n### 공통 UI 컴포넌트\n- **Button**: Primary, Secondary, Ghost 버튼\n- **Input**: 텍스트 입력 필드\n- **Select**: 드롭다운 선택 컴포넌트\n- **Modal**: 모달 다이얼로그\n- **Card**: 정보 카드 컨테이너\n- **Badge**: 상태 배지\n- **Table**: 데이터 테이블\n- **Pagination**: 페이지네이션\n- **FileUpload**: 파일 업로드 컴포넌트\n- **DatePicker**: 날짜 선택기\n\n### 페이지별 특화 컴포넌트\n\n#### 대시보드 페이지\n- **DashboardLayout**: 대시보드 레이아웃\n  - **StatCard**: 통계 카드 (미지정/진행중/완료 건수)\n  - **RecentActivity**: 최근 활동 피드\n  - **QuickActions**: 빠른 작업 버튼 그룹\n\n#### 해석 요청 관련 페이지\n- **RequestTable**: 요청 목록 테이블\n  - **RequestRow**: 개별 요청 행\n  - **StatusBadge**: 상태 배지\n- **RequestForm**: 새 요청 작성 폼\n- **RequestDetail**: 요청 상세 정보\n  - **RequestTabs**: 탭 네비게이션 (정보/파일/히스토리)\n  - **FileManager**: 파일 관리 인터페이스\n  - **ActivityTimeline**: 활동 히스토리 타임라인\n\n#### 캘린더 페이지\n- **CalendarView**: 캘린더 메인 컨테이너\n  - **CalendarHeader**: 월/주 전환 및 네비게이션\n  - **MonthView**: 월간 캘린더 뷰\n  - **WeekView**: 주간 캘린더 뷰\n  - **EventCard**: 일정 카드 (해석 요청)\n\n#### 칸반 보드 페이지\n- **KanbanBoard**: 칸반 보드 컨테이너\n  - **KanbanColumn**: 개별 컬럼 (담당자지정필요/작업전/진행중/완료)\n  - **KanbanCard**: 드래그 가능한 요청 카드\n  - **DropZone**: 드롭 영역 하이라이트\n\n#### 파일 관리 페이지\n- **FileExplorer**: 파일 탐색기 메인 컨테이너\n  - **FileGrid**: 파일 그리드 뷰\n  - **FileItem**: 개별 파일 항목\n  - **FilePreview**: 파일 미리보기 모달\n\n#### 통계 페이지\n- **StatsDashboard**: 통계 대시보드 컨테이너\n  - **KPICards**: 핵심 지표 카드 그룹\n  - **ChartContainer**: 차트 컨테이너\n    - **PieChart**: 차종별 분포 파이 차트\n    - **LineChart**: 월별 완료 트렌드 라인 차트\n  - **FilterPanel**: 기간 및 조건 필터 패널\n\n#### 설정 페이지\n- **SettingsLayout**: 설정 페이지 레이아웃\n  - **SettingsSidebar**: 설정 카테고리 사이드바\n  - **ProfileForm**: 프로필 편집 폼\n  - **AccountForm**: 계정 설정 폼\n  - **NotificationSettings**: 알림 설정 패널\n\n### 컴포넌트 재사용 원칙\n1. **단일 책임**: 각 컴포넌트는 명확한 하나의 역할만 수행\n2. **조합 가능**: 작은 컴포넌트들을 조합하여 복잡한 UI 구성\n3. **상태 분리**: 비즈니스 로직과 UI 표현 분리\n4. **일관된 인터페이스**: Props 네이밍과 구조의 일관성 유지\n5. **접근성 고려**: 모든 인터랙티브 컴포넌트에 적절한 ARIA 속성 제공\n\n---\n\n**작성일**: 2024년 12월 19일  \n**작성자**: UX Architect AI  \n**문서 버전**: 1.0  \n**검토 상태**: 초안 완료",
      "writedAt": "2025-10-04T03:09:12.192Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-10-04T03:09:12.192Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-10-04T03:09:12.192Z"
    }
  ]
}